//一个整数 n，n&1 这个表达式 可以用来 判断 a的奇偶性。
//二进制的末位为 0表示偶数，末位为 1表是奇数。
//使用 n%2 来判断奇偶性 和 n&1 是一样的作用，但是 n&1 要快好多。

// 按位与：&
//将参与运算的两操作数各对应的二进制位进行与操作，
//只有对应的两个二进位均为1时，结果的对应二进制位才为1，否则为0 

//记住：在做位运算时，位数不够的数，自动在 前面补 0
//比如：21 & 1 ：10101 & 00001 = 00001 = 1
//      16 & 1 ：10000 & 00001 = 00000 = 0 

#include <stdio.h>
int main(){
    int n;
    while(~scanf("%d",&n)){
        if(n&1)
            printf("%d是奇数\n",n);
        else
            printf("%d是偶数\n",n);
    }
    return 0; 
} 

//事实证明：偶数的二进制的末尾 为0，奇数的二进制的末尾 为1 

//十进制m 转换 n进制方法： m 一直除 n，每相除一次，m就等于商，直到商为0，然后余数反排 即可。 

//1的二进制：1/2 =0 余1
//余数反排 即是 1的二进制：1 

//6的二进制：6/2 =3 余0
//           3/2 =1 余1
//           1/2 =0 余1 
//余数反排 即是 6的二进制：110

//15的二进制：15/2=7 余1
//            7/2=3 余1
//            3/2=1 余1
//            1/2=0 余1
//余数反排 即是 15的二进制：1111 

//5的二进制：5/2 =2 余1
//           2/2 =1 余0 
//           1/2 =0 余1
//余数反排 即是 5的二进制：101

//21的二进制：21/2 =10 余1
//            10/2 =5 余0
//            5/2 =2 余1
//            2/2 =1 余0
//            1/2 =0 余1
//余数反排 即是 21的二进制：10101 

 
