#include <stdio.h> 
int main(){
    int n,m;
    while(~scanf("%d %d",&n,&m)){
        n^=m;
        m^=n;
        n^=m;
        printf("%d %d\n",n,m);
    }
    return 0;
}

//按位异或 ^ : 不相同 为：1 ; 相同 为 ：0 
//将参与运算的两操作数各对应的二进制位进行异或操作，
//即只有对应的两个二进位不相同时，结果的对应二进制
//位才是1，否则为0。

//异或运算的特点是：
//如果 a^b=c，那么就有 c^b = a以及c^a=b。

//例如：表达式“21 ^ 18 ”的值是7(即二进制数111)。
//21：    10101
//18：    10010
//21^18:  00111

//假设 n = 5，m = 6 
//5的二进制为：101
//6的二进制为：110 

//n^=m = 5^=6   = 101 ^ 110 = 011 ,此时 n的二进制为：011 
//m^=n = 6^=011 = 110 ^ 011 = 101 ,此时 m的二进制为：101，也正是 5的二进制数，也就是说 m ==开始的n 
//n^=m = 011^=5 = 011 ^ 101 = 110 ,此时 n的二进制位：110，也正是 6的二进制数，也就是说 n ==开始的m
//层次结构：A->B  B->A  A->B 正 反 正 

//不得不说，这很神奇，说下自己的思路

//第一步，n^=m; 先找出 这两个数的 异或数，并赋给 n。
//特别注意的是：这个异或数，就相当于 一个穿梭门。
//如果有两个人 甲与乙，甲 通过穿梭门会变成乙 而乙 通过穿梭门 会变成甲。 
 
//第二步，m^=n; m 对 异或数 进行异或运算， 正如 m 穿过 穿梭门 变成了 开始n

//第三步，n^=m; 这里可以换种方式理解，因为在第一步，穿梭门的值赋给了 n ,在第二步，m 成为了 开始的n 
//而这第三步 n^=m; 等价于 开始的n 穿过 穿梭门，并把值 赋给 n，所以答案显而易见，n 成为了 开始的m 
//是的，交换成功，你不得不服，这牛掰的位运算。 





